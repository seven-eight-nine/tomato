using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Tomato.DeepCloneGenerator
{
    internal static class CodeEmitter
    {
        /// <summary>
        /// Generates the DeepClone implementation for a type.
        /// </summary>
        public static string Generate(INamedTypeSymbol typeSymbol, List<MemberInfo> members, bool hasCyclable)
        {
            var sb = new StringBuilder();
            var typeName = typeSymbol.Name;
            var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isClass = typeSymbol.TypeKind == TypeKind.Class;

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            // Namespace
            var ns = typeSymbol.ContainingNamespace;
            if (!ns.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {ns.ToDisplayString()}");
                sb.AppendLine("{");
            }

            // Generate containing type wrappers if nested
            var containingTypes = new List<INamedTypeSymbol>();
            var containingType = typeSymbol.ContainingType;
            while (containingType != null)
            {
                containingTypes.Insert(0, containingType);
                containingType = containingType.ContainingType;
            }

            var indent = ns.IsGlobalNamespace ? "" : "    ";
            foreach (var ct in containingTypes)
            {
                var ctModifiers = GetTypeModifiers(ct);
                sb.AppendLine($"{indent}{ctModifiers} partial {GetTypeKind(ct)} {ct.Name}");
                sb.AppendLine($"{indent}{{");
                indent += "    ";
            }

            // Type declaration
            var modifiers = GetTypeModifiers(typeSymbol);
            var typeKind = GetTypeKind(typeSymbol);

            if (isClass)
            {
                sb.AppendLine($"{indent}{modifiers} partial {typeKind} {typeName} : global::Tomato.DeepCloneGenerator.IDeepCloneable<{typeName}>");
            }
            else
            {
                // Structs can't implement the interface directly since IDeepCloneable<T> has `where T : class`
                sb.AppendLine($"{indent}{modifiers} partial {typeKind} {typeName}");
            }
            sb.AppendLine($"{indent}{{");

            var memberIndent = indent + "    ";

            // Generate DeepClone method
            sb.AppendLine($"{memberIndent}/// <summary>");
            sb.AppendLine($"{memberIndent}/// Creates a deep clone of this instance.");
            sb.AppendLine($"{memberIndent}/// </summary>");
            sb.AppendLine($"{memberIndent}public {typeName} DeepClone()");
            sb.AppendLine($"{memberIndent}{{");

            if (hasCyclable)
            {
                sb.AppendLine($"{memberIndent}    try");
                sb.AppendLine($"{memberIndent}    {{");
                sb.AppendLine($"{memberIndent}        return DeepCloneInternal();");
                sb.AppendLine($"{memberIndent}    }}");
                sb.AppendLine($"{memberIndent}    finally");
                sb.AppendLine($"{memberIndent}    {{");
                sb.AppendLine($"{memberIndent}        global::Tomato.DeepCloneGenerator.DeepCloneCycleTracker.Clear();");
                sb.AppendLine($"{memberIndent}    }}");
            }
            else
            {
                sb.AppendLine($"{memberIndent}    return DeepCloneInternal();");
            }
            sb.AppendLine($"{memberIndent}}}");
            sb.AppendLine();

            // Generate DeepCloneInternal method (internal for cross-type cycle tracking)
            sb.AppendLine($"{memberIndent}internal {typeName} DeepCloneInternal()");
            sb.AppendLine($"{memberIndent}{{");
            sb.AppendLine($"{memberIndent}    var clone = new {typeName}();");

            // Register self immediately to handle circular references
            if (hasCyclable && isClass)
            {
                sb.AppendLine($"{memberIndent}    global::Tomato.DeepCloneGenerator.DeepCloneCycleTracker.Register(this, clone);");
            }

            foreach (var member in members)
            {
                if (member.IsReadonly)
                    continue;

                GenerateMemberClone(sb, member, memberIndent + "    ");
            }

            sb.AppendLine($"{memberIndent}    return clone;");
            sb.AppendLine($"{memberIndent}}}");

            // Close type
            sb.AppendLine($"{indent}}}");

            // Close containing types
            for (int i = containingTypes.Count - 1; i >= 0; i--)
            {
                indent = indent.Substring(4);
                sb.AppendLine($"{indent}}}");
            }

            // Close namespace
            if (!ns.IsGlobalNamespace)
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static void GenerateMemberClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var type = member.Type;
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            switch (member.Strategy)
            {
                case CopyStrategy.Skip:
                    // [DeepCloneOption.Ignore] - set to default
                    sb.AppendLine($"{indent}clone.{name} = default;");
                    break;

                case CopyStrategy.ValueCopy:
                case CopyStrategy.ReferenceCopy:
                case CopyStrategy.ImmutableReference:
                    sb.AppendLine($"{indent}clone.{name} = this.{name};");
                    break;

                case CopyStrategy.Nullable:
                    GenerateNullableClone(sb, member, indent);
                    break;

                case CopyStrategy.Array:
                    GenerateArrayClone(sb, member, indent);
                    break;

                case CopyStrategy.JaggedArray:
                    GenerateJaggedArrayClone(sb, member, indent);
                    break;

                case CopyStrategy.MultiDimensionalArray2:
                    GenerateMultiDimensionalArray2Clone(sb, member, indent);
                    break;

                case CopyStrategy.MultiDimensionalArray3:
                    GenerateMultiDimensionalArray3Clone(sb, member, indent);
                    break;

                case CopyStrategy.List:
                    GenerateListClone(sb, member, indent);
                    break;

                case CopyStrategy.Dictionary:
                    GenerateDictionaryClone(sb, member, indent);
                    break;

                case CopyStrategy.HashSet:
                    GenerateHashSetClone(sb, member, indent);
                    break;

                case CopyStrategy.Queue:
                    GenerateQueueClone(sb, member, indent);
                    break;

                case CopyStrategy.Stack:
                    GenerateStackClone(sb, member, indent);
                    break;

                case CopyStrategy.LinkedList:
                    GenerateLinkedListClone(sb, member, indent);
                    break;

                case CopyStrategy.SortedList:
                    GenerateSortedListClone(sb, member, indent);
                    break;

                case CopyStrategy.SortedDictionary:
                    GenerateSortedDictionaryClone(sb, member, indent);
                    break;

                case CopyStrategy.SortedSet:
                    GenerateSortedSetClone(sb, member, indent);
                    break;

                case CopyStrategy.ConcurrentDictionary:
                    GenerateConcurrentDictionaryClone(sb, member, indent);
                    break;

                case CopyStrategy.ConcurrentQueue:
                    GenerateConcurrentQueueClone(sb, member, indent);
                    break;

                case CopyStrategy.ConcurrentStack:
                    GenerateConcurrentStackClone(sb, member, indent);
                    break;

                case CopyStrategy.ConcurrentBag:
                    GenerateConcurrentBagClone(sb, member, indent);
                    break;

                case CopyStrategy.ReadOnlyCollection:
                    GenerateReadOnlyCollectionClone(sb, member, indent);
                    break;

                case CopyStrategy.ObservableCollection:
                    GenerateObservableCollectionClone(sb, member, indent);
                    break;

                case CopyStrategy.DeepCloneable:
                    GenerateDeepCloneableClone(sb, member, indent);
                    break;

                case CopyStrategy.TypeParameter:
                    GenerateTypeParameterClone(sb, member, indent);
                    break;

                case CopyStrategy.Collection:
                    GenerateCollectionClone(sb, member, indent);
                    break;

                case CopyStrategy.ShallowWithWarning:
                    sb.AppendLine($"{indent}clone.{name} = this.{name}; // Warning: shallow copy");
                    break;
            }
        }

        private static void GenerateNullableClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            sb.AppendLine($"{indent}clone.{name} = this.{name};");
        }

        private static void GenerateArrayClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new {elementTypeName}[this.{name}.Length];");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    for (int i = 0; i < this.{name}.Length; i++)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (this.{name}[i] != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[i] = this.{name}[i].DeepCloneInternal();");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateListClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);
            var isCyclable = member.Option == CloneOption.Cyclable;

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.List<{elementTypeName}>(this.{name}.Count);");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    clone.{name}.AddRange(this.{name});");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                if (isCyclable)
                {
                    sb.AppendLine($"{indent}            if (global::Tomato.DeepCloneGenerator.DeepCloneCycleTracker.TryGetClone(item, out {elementTypeName}? cachedItem))");
                    sb.AppendLine($"{indent}            {{");
                    sb.AppendLine($"{indent}                clone.{name}.Add(cachedItem!);");
                    sb.AppendLine($"{indent}            }}");
                    sb.AppendLine($"{indent}            else");
                    sb.AppendLine($"{indent}            {{");
                    sb.AppendLine($"{indent}                clone.{name}.Add(item.DeepCloneInternal());");
                    sb.AppendLine($"{indent}            }}");
                }
                else
                {
                    sb.AppendLine($"{indent}            clone.{name}.Add(item.DeepCloneInternal());");
                }
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    clone.{name}.AddRange(this.{name});");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateDictionaryClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var keyType = member.KeyType!;
            var valueType = member.ValueType!;
            var keyTypeName = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isValueDeepCloneable = IsDeepCloneable(valueType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Preserve comparer
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>(this.{name}.Count, this.{name}.Comparer);");

            if (IsSimpleType(valueType))
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isValueDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (kvp.Value != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value.DeepCloneInternal();");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateHashSetClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");

            if (IsSimpleType(elementType))
            {
                // Preserve comparer
                sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.HashSet<{elementTypeName}>(this.{name}, this.{name}.Comparer);");
            }
            else if (isElementDeepCloneable)
            {
                // Preserve comparer
                sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.HashSet<{elementTypeName}>(this.{name}.Comparer);");
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                // Preserve comparer
                sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.HashSet<{elementTypeName}>(this.{name}, this.{name}.Comparer);");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateQueueClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.Queue<{elementTypeName}>(this.{name}.Count);");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Enqueue(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Enqueue(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Enqueue(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Enqueue(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateStackClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Stack needs to be reversed to maintain order
            sb.AppendLine($"{indent}    var tempArray = this.{name}.ToArray();");
            sb.AppendLine($"{indent}    global::System.Array.Reverse(tempArray);");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.Stack<{elementTypeName}>(tempArray.Length);");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Push(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Push(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Push(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Push(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateLinkedListClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.LinkedList<{elementTypeName}>();");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.AddLast(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.AddLast(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.AddLast(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.AddLast(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateSortedListClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var keyType = member.KeyType!;
            var valueType = member.ValueType!;
            var keyTypeName = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isValueDeepCloneable = IsDeepCloneable(valueType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Preserve comparer
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.SortedList<{keyTypeName}, {valueTypeName}>(this.{name}.Count, this.{name}.Comparer);");

            if (IsSimpleType(valueType))
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isValueDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (kvp.Value != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value.DeepCloneInternal();");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateSortedDictionaryClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var keyType = member.KeyType!;
            var valueType = member.ValueType!;
            var keyTypeName = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isValueDeepCloneable = IsDeepCloneable(valueType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Preserve comparer
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.SortedDictionary<{keyTypeName}, {valueTypeName}>(this.{name}.Comparer);");

            if (IsSimpleType(valueType))
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isValueDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (kvp.Value != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value.DeepCloneInternal();");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateSortedSetClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Preserve comparer
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Generic.SortedSet<{elementTypeName}>(this.{name}.Comparer);");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateConcurrentDictionaryClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var keyType = member.KeyType!;
            var valueType = member.ValueType!;
            var keyTypeName = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isValueDeepCloneable = IsDeepCloneable(valueType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Concurrent.ConcurrentDictionary<{keyTypeName}, {valueTypeName}>();");

            if (IsSimpleType(valueType))
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isValueDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (kvp.Value != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value.DeepCloneInternal();");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var kvp in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}[kvp.Key] = kvp.Value;");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateConcurrentQueueClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Concurrent.ConcurrentQueue<{elementTypeName}>();");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Enqueue(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Enqueue(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Enqueue(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Enqueue(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateConcurrentStackClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            // Stack needs to be reversed to maintain order
            sb.AppendLine($"{indent}    var tempArray = this.{name}.ToArray();");
            sb.AppendLine($"{indent}    global::System.Array.Reverse(tempArray);");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Concurrent.ConcurrentStack<{elementTypeName}>();");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Push(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Push(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Push(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in tempArray)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Push(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateConcurrentBagClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.Concurrent.ConcurrentBag<{elementTypeName}>();");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateReadOnlyCollectionClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    var tempList = new global::System.Collections.Generic.List<{elementTypeName}>(this.{name}.Count);");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        tempList.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            tempList.Add(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            tempList.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        tempList.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.ObjectModel.ReadOnlyCollection<{elementTypeName}>(tempList);");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateObservableCollectionClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var elementType = member.ElementType!;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new global::System.Collections.ObjectModel.ObservableCollection<{elementTypeName}>();");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (item != null)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item.DeepCloneInternal());");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            clone.{name}.Add(item!);");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    foreach (var item in this.{name})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name}.Add(item);");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateJaggedArrayClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var type = member.Type as IArrayTypeSymbol;
            if (type == null) return;

            var innerArrayType = type.ElementType as IArrayTypeSymbol;
            if (innerArrayType == null) return;

            var elementType = innerArrayType.ElementType;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = new {elementTypeName}[this.{name}.Length][];");
            sb.AppendLine($"{indent}    for (int i = 0; i < this.{name}.Length; i++)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (this.{name}[i] != null)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            clone.{name}[i] = new {elementTypeName}[this.{name}[i].Length];");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}            global::System.Array.Copy(this.{name}[i], clone.{name}[i], this.{name}[i].Length);");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}            for (int j = 0; j < this.{name}[i].Length; j++)");
                sb.AppendLine($"{indent}            {{");
                sb.AppendLine($"{indent}                if (this.{name}[i][j] != null)");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    clone.{name}[i][j] = this.{name}[i][j].DeepCloneInternal();");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine($"{indent}            }}");
            }
            else
            {
                sb.AppendLine($"{indent}            global::System.Array.Copy(this.{name}[i], clone.{name}[i], this.{name}[i].Length);");
            }

            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateMultiDimensionalArray2Clone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var type = member.Type as IArrayTypeSymbol;
            if (type == null) return;

            var elementType = type.ElementType;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    int dim0 = this.{name}.GetLength(0);");
            sb.AppendLine($"{indent}    int dim1 = this.{name}.GetLength(1);");
            sb.AppendLine($"{indent}    clone.{name} = new {elementTypeName}[dim0, dim1];");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    for (int i = 0; i < dim0; i++)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        for (int j = 0; j < dim1; j++)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            if (this.{name}[i, j] != null)");
                sb.AppendLine($"{indent}            {{");
                sb.AppendLine($"{indent}                clone.{name}[i, j] = this.{name}[i, j].DeepCloneInternal();");
                sb.AppendLine($"{indent}            }}");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateMultiDimensionalArray3Clone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var type = member.Type as IArrayTypeSymbol;
            if (type == null) return;

            var elementType = type.ElementType;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isElementDeepCloneable = IsDeepCloneable(elementType);

            sb.AppendLine($"{indent}if (this.{name} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    int dim0 = this.{name}.GetLength(0);");
            sb.AppendLine($"{indent}    int dim1 = this.{name}.GetLength(1);");
            sb.AppendLine($"{indent}    int dim2 = this.{name}.GetLength(2);");
            sb.AppendLine($"{indent}    clone.{name} = new {elementTypeName}[dim0, dim1, dim2];");

            if (IsSimpleType(elementType))
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }
            else if (isElementDeepCloneable)
            {
                sb.AppendLine($"{indent}    for (int i = 0; i < dim0; i++)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        for (int j = 0; j < dim1; j++)");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            for (int k = 0; k < dim2; k++)");
                sb.AppendLine($"{indent}            {{");
                sb.AppendLine($"{indent}                if (this.{name}[i, j, k] != null)");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    clone.{name}[i, j, k] = this.{name}[i, j, k].DeepCloneInternal();");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine($"{indent}            }}");
                sb.AppendLine($"{indent}        }}");
                sb.AppendLine($"{indent}    }}");
            }
            else
            {
                sb.AppendLine($"{indent}    global::System.Array.Copy(this.{name}, clone.{name}, this.{name}.Length);");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateTypeParameterClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var typeName = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Type parameter - check at runtime if it's IDeepCloneable
            sb.AppendLine($"{indent}if (this.{name} is global::Tomato.DeepCloneGenerator.IDeepCloneable<{typeName}> cloneable{name})");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = cloneable{name}.DeepClone();");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    clone.{name} = this.{name};");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateCollectionClone(StringBuilder sb, MemberInfo member, string indent)
        {
            // Fallback for ICollection<T> - shallow copy with comment
            var name = member.Name;
            sb.AppendLine($"{indent}clone.{name} = this.{name}; // Collection type not specifically supported, shallow copy");
        }

        private static void GenerateDeepCloneableClone(StringBuilder sb, MemberInfo member, string indent)
        {
            var name = member.Name;
            var typeName = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (member.Option == CloneOption.Cyclable)
            {
                sb.AppendLine($"{indent}if (this.{name} != null)");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    if (global::Tomato.DeepCloneGenerator.DeepCloneCycleTracker.TryGetClone(this.{name}, out {typeName}? cached))");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        clone.{name} = cached;");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine($"{indent}    else");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        var clonedValue = this.{name}.DeepCloneInternal();");
                sb.AppendLine($"{indent}        global::Tomato.DeepCloneGenerator.DeepCloneCycleTracker.Register(this.{name}, clonedValue);");
                sb.AppendLine($"{indent}        clone.{name} = clonedValue;");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine($"{indent}}}");
            }
            else
            {
                sb.AppendLine($"{indent}if (this.{name} != null)");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    clone.{name} = this.{name}.DeepCloneInternal();");
                sb.AppendLine($"{indent}}}");
            }
        }

        private static bool IsSimpleType(ITypeSymbol type)
        {
            if (type.IsValueType)
                return true;
            if (type.SpecialType == SpecialType.System_String)
                return true;
            return false;
        }

        private static bool IsDeepCloneable(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                // Check for DeepClonable attribute
                foreach (var attr in namedType.GetAttributes())
                {
                    if (attr.AttributeClass?.ToDisplayString() == "Tomato.DeepCloneGenerator.DeepClonableAttribute")
                        return true;
                }

                // Check for IDeepCloneable<T> interface
                foreach (var iface in namedType.AllInterfaces)
                {
                    if (iface.OriginalDefinition.ToDisplayString() == "Tomato.DeepCloneGenerator.IDeepCloneable<T>")
                        return true;
                }
            }
            return false;
        }

        private static string GetTypeModifiers(INamedTypeSymbol typeSymbol)
        {
            return typeSymbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Private => "private",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedOrInternal => "protected internal",
                Accessibility.ProtectedAndInternal => "private protected",
                _ => "internal"
            };
        }

        private static string GetTypeKind(INamedTypeSymbol typeSymbol)
        {
            return typeSymbol.TypeKind switch
            {
                TypeKind.Class => typeSymbol.IsRecord ? "record" : "class",
                TypeKind.Struct => typeSymbol.IsRecord ? "record struct" : "struct",
                _ => "class"
            };
        }
    }
}
